package Security;

import org.jivesoftware.smack.util.Base64;
import org.whispersystems.libaxolotl.*;
import org.whispersystems.libaxolotl.InvalidKeyException;
import org.whispersystems.libaxolotl.ecc.Curve;
import org.whispersystems.libaxolotl.ecc.ECKeyPair;
import org.whispersystems.libaxolotl.protocol.PreKeyWhisperMessage;
import org.whispersystems.libaxolotl.protocol.WhisperMessage;
import org.whispersystems.libaxolotl.state.AxolotlStore;
import org.whispersystems.libaxolotl.state.PreKeyBundle;
import org.whispersystems.libaxolotl.state.PreKeyRecord;
import org.whispersystems.libaxolotl.state.SignedPreKeyRecord;
import org.whispersystems.libaxolotl.state.impl.InMemoryAxolotlStore;

import java.io.IOException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.UnrecoverableEntryException;
import java.security.cert.CertificateException;
import java.util.HashMap;

/**
 * Created by ben on 28/11/15.
 */
public class SecureParty
{
    //Similar for all sessions
    private String email;
    private int numericId;
    private IdentityKeyPair identityKeyPair;
    private ECKeyPair signedPair;
    private byte[] signedPreKeySignature;
    private AxolotlStore store;
    private ITrustStore trustStore;
    private IWitnessGenerator witnessGenerator;

    private HashMap<String, SecureSessionContext> sessions;

    public SecureParty(String email, ITrustStore trustStore, IWitnessGenerator witnessGenerator) throws
            CertificateException, NoSuchAlgorithmException, KeyStoreException,
            UnrecoverableEntryException, InvalidKeyException, IOException {

        this.trustStore = trustStore;
        this.witnessGenerator = witnessGenerator;
        sessions = new HashMap<>();
        this.email = email;
        this.numericId = email.hashCode();
        initializeAxolotlStore(email);
    }

    public IIdentityWitness generateWitness()
    {
        return witnessGenerator.generateWitness(identityKeyPair.getPublicKey());
    }

    private AxolotlStore generateKeyStore(String email) throws CertificateException, NoSuchAlgorithmException,
            KeyStoreException, IOException, UnrecoverableEntryException, InvalidKeyException {

        IdentityKeyPair idPair = trustStore.getIdentity();

        if(null == idPair)
        {
            //Set the identity key
            ECKeyPair ecPair = Curve.generateKeyPair();
            IdentityKey idKey = new IdentityKey(ecPair.getPublicKey());
            idPair = new IdentityKeyPair(idKey, ecPair.getPrivateKey());
            trustStore.setIdentity(idPair);
        }

        //Create an in-memory Axolotl store (non-persistent)
        return new InMemoryAxolotlStore(idPair, numericId);
    }

    private int getSignedPrekeyId()
    {
        return (email + "signed").hashCode();
    }

    private void initializeAxolotlStore(String email) throws CertificateException, InvalidKeyException,
            NoSuchAlgorithmException, KeyStoreException, UnrecoverableEntryException, IOException {

        store = generateKeyStore(email);

        //Load the identity key pair from the store
        identityKeyPair = store.getIdentityKeyPair();

        //generate a signed prekey pair
        signedPair = Curve.generateKeyPair();

        //Sign the signed prekey
        signedPreKeySignature = Curve.calculateSignature(identityKeyPair.getPrivateKey(),
                signedPair.getPublicKey().serialize());

        //Store the signed prekey
        SignedPreKeyRecord record = new SignedPreKeyRecord(getSignedPrekeyId(),
                0, signedPair, signedPreKeySignature);
        store.storeSignedPreKey(getSignedPrekeyId(), record);
    }

    public String createKeyExchangeMessage(String peer)
    {
        //Create new ephemeral key
        ECKeyPair ephemeralPair = Curve.generateKeyPair();

        //Get an id for the prekey for this peer
        int prekeyId = peer.hashCode();
        PreKeyRecord record = new PreKeyRecord(prekeyId, ephemeralPair);

        // remove the old prekey in case we already had a conversation
        store.removePreKey(prekeyId);

        //Store the new prekey
        store.storePreKey(prekeyId, record);

        return KeyExchangeUtil.serialize(new PreKeyBundle(numericId, numericId, prekeyId,
                ephemeralPair.getPublicKey(), getSignedPrekeyId(), signedPair.getPublicKey(),
                signedPreKeySignature, identityKeyPair.getPublicKey()));
    }

    public boolean isSessionInitialized(String peer)
    {   return null != sessions.get(peer);  }

    /**
     * Builds a secure session with peer, based on a key
     * exchange message generated by peer
     * @param peer
     * @param keyExchangeMessage
     * @return true is the user is trusted, false otherwise
     */
    public boolean consumeKeyExchangeMessage(String peer, String keyExchangeMessage) throws UnrecoverableEntryException,
            NoSuchAlgorithmException, KeyStoreException, UntrustedIdentityException, InvalidKeyException {

        if(isSessionInitialized(peer))
        {
            //Remove old session
            sessions.remove(peer);
        }

        //Create a session builder
        AxolotlAddress remoteAddress = new AxolotlAddress(peer, peer.hashCode());
        SessionBuilder builder = new SessionBuilder(store, remoteAddress);

        //Process the counterpart prekey
        PreKeyBundle bundle = KeyExchangeUtil.deserialize(keyExchangeMessage);
        builder.process(bundle);
        SecureSessionContext ctx = new SecureSessionContext(new SessionCipher(store, remoteAddress),
                bundle.getIdentityKey());
        sessions.put(peer,ctx);

        //Check if the peer is trusted
        if(trustStore.isTrusted(peer,bundle.getIdentityKey().getPublicKey()))
        {
            return true;
        }

        return false;
    }

    /**
     * Once the user receives a witness for the peers public key,
     * that is, some piece of data that can authenticate the identity key,
     * call this method.
     *
     * IMPORTANT - this method must be called when a session is in progress
     * with this peer, and the user is aware of the process
     *
     * @param peer
     * @param witness
     * @return true if the witness fits the session identity key
     */
    public boolean consumeIdentityWitness(String peer, IIdentityWitness witness) throws CertificateException, NoSuchAlgorithmException, KeyStoreException, IOException {
        SecureSessionContext ctx = sessions.get(peer);
        if(null == ctx || !witness.authenticate(ctx.getSessionIdentityKey()))
        {
            return false;
        }
        trustStore.setTrustedIdentity(peer, ctx.getSessionIdentityKey());
        return true;
    }


    public String encrypt(String peer, String plaintext)
    {
        return Base64.encodeBytes(sessions.get(peer).getSessionCipher().encrypt(plaintext.getBytes()).serialize());
    }

    public byte[] decryptPreKeyMessage(String peer, String ciphertext) throws InvalidVersionException,
            InvalidMessageException, InvalidKeyException, DuplicateMessageException, InvalidKeyIdException,
            UntrustedIdentityException, LegacyMessageException {

        byte[] plaintext =  sessions.get(peer).getSessionCipher()
                .decrypt(new PreKeyWhisperMessage(Base64.decode(ciphertext)));;

        return plaintext;
    }


    public String decrypt(String peer, String ciphertext) throws UntrustedIdentityException, LegacyMessageException,
            InvalidVersionException, InvalidMessageException, DuplicateMessageException,
            InvalidKeyException, InvalidKeyIdException, NoSessionException {

        byte[] plaintext = null;

        try {

            //Try to parse it as WhisperMessage
            plaintext = sessions.get(peer).getSessionCipher()
                    .decrypt(new WhisperMessage(Base64.decode(ciphertext)));

        } catch (InvalidMessageException e) {

            //We failed to parse it as WhisperMessage, maybe its PreKeyWhisperMessage
            plaintext = decryptPreKeyMessage(peer, ciphertext);

        }

        return new String(plaintext);
    }
}
